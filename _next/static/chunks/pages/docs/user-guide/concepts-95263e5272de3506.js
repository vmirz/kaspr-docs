(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[777],{612:function(e,a,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/user-guide/concepts",function(){return n(3838)}])},3838:function(e,a,n){"use strict";n.r(a),n.d(a,{useTOC:function(){return useTOC}});var t=n(5893),s=n(7812),i=n(9601),r=n(8925);function useTOC(e){return[{value:"Application (App)",id:"application-app",depth:2},{value:"Stream",id:"stream",depth:2},{value:"Agent",id:"agent",depth:2},{value:"Table",id:"table",depth:2},{value:"Task",id:"task",depth:2},{value:"Web View",id:"web-view",depth:2},{value:"Channel",id:"channel",depth:2}]}a.default=(0,s.c)(function(e){let{toc:a=useTOC(e)}=e,n={a:"a",h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"Concepts"}),"\n",(0,t.jsx)(n.p,{children:"This section provides an overview of the concepts that are important to understand when working with Kaspr."}),"\n",(0,t.jsx)(n.h2,{id:a[0].id,children:a[0].value}),"\n",(0,t.jsxs)(n.p,{children:["An app (",(0,t.jsx)(n.a,{href:"/api-reference/v1alpha1#kasprapp",children:"KasprApp"}),") is a program that runs all the components of a distributed stream processing application.  It is composed of agents (stream processors), tasks, channels, tables, and web views to perform useful work.\nWe can have multiple instances of an app to distribute a processing and scale in a horizontal manner."]}),"\n",(0,t.jsx)(n.p,{children:"An app can be seen as a service in a microservice architecture. It’s common to have many different apps, each responsible for a set of functions, that are part of a larger or complex system.\n…"}),"\n",(0,t.jsx)(n.h2,{id:a[1].id,children:a[1].value}),"\n",(0,t.jsxs)(n.p,{children:["A stream is an infinite sequence of events coming from a Kafka topic or channel. In Kaspr, a stream is implicitly created through an (",(0,t.jsx)(n.a,{href:"#agent",children:"KasprAgent"}),"), which manages the stream’s lifecycle, determines what enters the stream, and defines how its events are processed."]}),"\n",(0,t.jsx)(n.p,{children:"An event serves as a general wrapper for messages. Each event contains references to both the serialized and deserialized versions of the key and value messages, along with additional metadata, such as the message offset."}),"\n",(0,t.jsx)(n.h2,{id:a[2].id,children:a[2].value}),"\n",(0,t.jsxs)(n.p,{children:["An agent (",(0,t.jsx)(n.a,{href:"/api-reference/v1alpha1#kaspragent",children:"KasprAgent"}),") is a distributed system that processes events in a stream. Each agent runs within an app, and an app can host multiple agents. An agent consumes data from an input source, such as a Kafka topic or a channel, and performs one or more processing operations on either individual events or batches of events."]}),"\n",(0,t.jsx)(n.p,{children:"Streams can be divided among agents either in a round-robin fashion or by partitioning them based on the message key. This determines how the stream is distributed across available agent instances within all app instances. For instance, if the stream’s messages are keyed by account ID and the value is a high score, the partitioning ensures that all messages with the same account ID are consistently processed by the same agent instance."}),"\n",(0,t.jsx)(n.p,{children:"Agents are at the core of stream processing in Kaspr, capable of performing a variety of operations, including transformations and aggregations, right out of the box. Additionally, agents can define custom processing logic using arbitrary Python code, providing flexibility for more complex operations."}),"\n",(0,t.jsx)(n.h2,{id:a[3].id,children:a[3].value}),"\n",(0,t.jsxs)(n.p,{children:["A (",(0,t.jsx)(n.a,{href:"/api-reference/v1alpha1#kasprtable",children:"KasprTable"}),") provides durable, fault-tolerant memory for stream processing. While similar to a database, a Table differs in key ways: instead of residing on a remote host and offering a rich query interface, a Table is a simple key-value store embedded directly within an application. This local embedding allows for ultra-fast reads and writes."]}),"\n",(0,t.jsx)(n.p,{children:"Each Table is backed by a Kafka topic, often compacted and referred to as a changelog topic. Every record written to a Table is also published to its changelog topic. This design enables the system to rebuild the entire state of the Table in case of a failure, ensuring data consistency and fault tolerance."}),"\n",(0,t.jsx)(n.p,{children:"Internally, a Table leverages an embedded RocksDB database. The data capacity of RocksDB is limited by the disk size of the machine, not its memory, making it suitable for managing large datasets."}),"\n",(0,t.jsx)(n.p,{children:"Tables play a critical role in enabling applications to store state in a fault-tolerant manner, allowing stream processors to perform stateful computations such as aggregations and data enrichments."}),"\n",(0,t.jsx)(n.p,{children:"There are two types of Tables: normal and global."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Normal"}),":\nA normal Table is distributed across instances of an application, as it is partitioned based on the partitions of the underlying changelog topic. In a multi-instance setup, each application instance holds a subset of the Table’s keys. However, in a single-instance setup, a normal Table behaves similarly to a global Table."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Global"}),":\nA global Table, by contrast, provides each application instance with a complete copy of the data. This distinction becomes important when scaling an application to run across multiple instances. Unlike normal Tables, which divide the dataset among instances, global Tables replicate the entire dataset to each instance.\nThis flexibility allows developers to choose the appropriate Table type based on their application’s requirements for scalability and data locality."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:a[4].id,children:a[4].value}),"\n",(0,t.jsxs)(n.p,{children:["A task (",(0,t.jsx)(n.a,{href:"/api-reference/v1alpha1#kasprtask",children:"KasprTask"}),") represents arbitrary work that is performed asynchronously in the background, independent of agents. Tasks can be defined to run as one-time operations, on fixed time intervals, or on a recurring schedule using loops or cron expressions."]}),"\n",(0,t.jsx)(n.p,{children:"Tasks operate within an app, and an app can run multiple tasks simultaneously."}),"\n",(0,t.jsx)(n.p,{children:"Some examples of how tasks can be used include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Polling external APIs and publishing data to a topic or channel"}),"\n",(0,t.jsx)(n.li,{children:"Reading from a (KasprTable) and performing an action, such as making a POST request to an HTTP endpoint"}),"\n",(0,t.jsx)(n.li,{children:"Triggering scheduled business processes"}),"\n",(0,t.jsx)(n.li,{children:"Generating synthetic data"}),"\n",(0,t.jsx)(n.li,{children:"Tasks provide a flexible way to perform background operations without blocking other processes within the app."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Tasks provide a powerful way to handle asynchronos operations in a kaspr application, enabling a wide variety of background processing needs."}),"\n",(0,t.jsx)(n.h2,{id:a[5].id,children:a[5].value}),"\n",(0,t.jsx)(n.p,{children:"TODO"}),"\n",(0,t.jsx)(n.h2,{id:a[6].id,children:a[6].value}),"\n",(0,t.jsxs)(n.p,{children:["A channel (",(0,t.jsx)(n.a,{href:"/api-reference/v1alpha1#kasprchannel",children:"KasprChannel"}),") is an in-memory buffer or queue used for sending and receiving messages within a local application (process) only. In Kaspr, channels function similarly to Kafka topics, enabling communication between agents within the same app. However, unlike Kafka topics, messages in channels do not persist across application restarts, meaning they are temporary and are lost when the app is restarted."]})]})},"/docs/user-guide/concepts",{filePath:"pages/docs/user-guide/concepts.mdx",timestamp:1734747159e3,pageMap:i.v,frontMatter:{},title:"Concepts"},"undefined"==typeof RemoteContent?useTOC:RemoteContent.useTOC)},9601:function(e,a,n){"use strict";n.d(a,{v:function(){return t}});let t=[{data:{index:{title:"Kaspr",type:"page",display:"hidden",theme:{layout:"raw"}},docs:{title:"Documentation",type:"page"}}},{name:"docs",route:"/docs",children:[{data:{index:"Overview","getting-started":"Getting Started","user-guide":"User Guide","api-reference":"Reference","---":{type:"separator"},copyright:"Copyright"}},{name:"api-reference",route:"/docs/api-reference",children:[{data:{v1alpha1:"V1Alpha1"}},{name:"v1alpha1",route:"/docs/api-reference/v1alpha1",frontMatter:{sidebarTitle:"V1alpha1"}}]},{name:"copyright",route:"/docs/copyright",frontMatter:{sidebarTitle:"Copyright"}},{name:"getting-started",route:"/docs/getting-started",children:[{data:{introduction:"Introduction",installation:"Install Kaspr Operator",architecture:"Architecture"}},{name:"architecture",route:"/docs/getting-started/architecture",frontMatter:{sidebarTitle:"Architecture"}},{name:"installation",route:"/docs/getting-started/installation",children:[{data:{helm:"Install with Helm"}},{name:"helm",route:"/docs/getting-started/installation/helm",frontMatter:{sidebarTitle:"Helm"}}]},{name:"installation",route:"/docs/getting-started/installation",frontMatter:{sidebarTitle:"Installation"}},{name:"introduction",route:"/docs/getting-started/introduction",frontMatter:{sidebarTitle:"Introduction"}}]},{name:"index",route:"/docs",frontMatter:{sidebarTitle:"Index"}},{name:"user-guide",route:"/docs/user-guide",children:[{data:{concepts:"Concepts","kafka-basics":"Kafka - Basics you need to know",agents:"Agents - Distributed stream processors"}},{name:"agents",route:"/docs/user-guide/agents",frontMatter:{sidebarTitle:"Agents"}},{name:"concepts",route:"/docs/user-guide/concepts",frontMatter:{sidebarTitle:"Concepts"}},{name:"kafka-basics",route:"/docs/user-guide/kafka-basics",frontMatter:{sidebarTitle:"Kafka Basics"}}]}]},{name:"index",route:"/",frontMatter:{title:"Kaspr – Event Streaming for Kubernetes"}}]}},function(e){e.O(0,[812,774,888,179],function(){return e(e.s=612)}),_N_E=e.O()}]);